<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <title>
      Presentation API
    </title>
    <style>
@media print {
     [data-anolis-spec]::after { content:"[" attr(data-anolis-spec) "]"; font-size:.6em; vertical-align:super; text-transform:uppercase }
    }
    </style>
    <link rel="stylesheet" href=
    "http://www.w3.org/community/src/css/spec/cg-final.css" type="text/css">
    <style type="text/css">
/* Note formatting taken from HTML5 spec */
    .note { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #E9FBE9; border-color: #52E052; }
    .note em, .warning em, .note i, .warning i { font-style: normal; }
    p.note, div.note { padding: 0.5em 2em; }
    span.note { padding: 0 2em; }
    .note p:first-child { margin-top: 0; }
    .note p:last-child { margin-bottom: 0; }
    p.note:before { content: 'Note: '; font-weight: bolder;}

    .open-issue { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #fbfbe9; border-color: #faf9a5; }
    .open-issue em, .warning em, .open-issue i, .warning i { font-style: normal; }
    p.open-issue, div.open-issue { padding: 0.5em 2em; }
    span.open-issue { padding: 0 2em; }
    .open-issue p:first-child { margin-top: 0; }
    .open-issue p:last-child { margin-bottom: 0; }
    p.open-issue:before { content: 'Open issue: '; font-weight: bolder;}

    .non-normative { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #E9FBE9; border-color: #52E052; }
    p.non-normative:before { content: 'Non-normative: '; font-weight: bolder;}
    p.non-normative, div.non-normative { padding: 0.5em 2em; }


    /* Pre.idl formatting taken from HTML5 spec */
    pre.idl { border: solid thin #d3d3d3; background: #FCFCFC; color: black; padding: 0.5em 1em; position: relative; }
    pre.idl :link, pre.idl :visited { color: inherit; background: transparent; }
    pre.idl::before { content: "IDL"; font: bold small sans-serif;
    padding: 0.5em; background: white; position: absolute; top: 0;
    margin: -1px 0 0 -4em; width: 1.5em; border: thin solid;
    border-radius: 0 0 0 0.5em }

    /* .example idl formatting taken from HTML5 nightly spec */
    .example {
        display: block;
        color: #222222;
        background: #FCFCFC;
        border-left-style: solid;
        border-color: #c0c0c0;
        border-left-width: 0.25em;
        margin-left: 1em;
        padding-left: 1em;
        padding-bottom: 0.5em;
    }

    .algorithm li {
        margin-bottom: 0.5em;
    }

    .interface dd, .parameters dt {
        margin-bottom: 0.5em;
    }

    code { color: orangered; }
    </style>
  </head>
  <body>
    <div class="head">
      <!--logo-->
      <h1>
        Presentation API
      </h1>
      <h2 class="no-num no-toc">
        (Draft of) Final Report [DATE]
      </h2>
      <dl>
        <dt>
          This Version:
        </dt>
        <dd>
          <!--begin-link-->http://webscreens.github.io/presentation-api/ 
          <!--end-link-->
        </dd>
        <dt>
          Latest Published Version
        </dt>
        <dd>
          <!--begin-link-->http://webscreens.github.io/presentation-api/ 
          <!--end-link-->
        </dd>
        <dt>
          <a id="previous-version">Previous Version:</a>
        </dt>
        <dd>
          <a href=
          "http://webscreens.github.io/presentation-api/20131112/">http://webscreens.github.io/presentation-api/20131112/</a>
        </dd>
        <dt>
          Participate:
        </dt>
        <dd>
          Send feedback to the community group's mailing list <a href=
          "http://lists.w3.org/Archives/Public/public-webscreens/">public-webscreens@w3.org</a>,
          or <a href=
          "https://github.com/webscreens/presentation-api/issues">create or
          browse open issues</a> on GitHub. Also, you may join on the <a href=
          "irc://irc.w3.org:6665/#webscreens">CG's IRC channel</a>.
        </dd>
        <dt>
          Version History:
        </dt>
        <dd>
          <!--begin-link-->https://github.com/webscreens/presentation-api/commits/<!--end-link-->
        </dd>
        <dt>
          Editors:
        </dt>
        <dd>
          <a href="mailto:dominik.rottsches@intel.com">Dominik Röttsches</a>,
          Intel
        </dd>
        <dd>
          <a href="mailto:anssi.kostianen@intel.com">Anssi Kostiainen,
          Intel</a>
        </dd>
      </dl>
      <p class="copyright">
        <a href=
        "http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>
        © 2014 the Contributors to the Presentation API Specification,
        published by the <a href=
        "http://www.w3.org/community/webscreens/">Second Screen Presentation
        Community Group</a> under the <a href=
        "https://www.w3.org/community/about/agreements/final/">W3C Community
        Final Specification Agreement (CLA)</a>.
      </p>
      <hr>
    </div>
    <h2 class="no-num no-toc">
      Abstract
    </h2>
    <p>
      This specification defines an API to enable web content to access
      external presentation-type displays and use them for presenting web
      content.
    </p>
    <h2 class="no-num no-toc" id="sotd">
      Status of this Document
    </h2>
    <p>
      This specification was published by the <a href=
      "http://www.w3.org/community/webscreens/">Second Screen Presentation
      Community Group</a>. It is not a W3C Standard nor is it on the W3C
      Standards Track. Please note that under the <a href=
      "http://www.w3.org/community/about/agreements/final/">W3C Community Final
      Specification Agreement (FSA)</a> other conditions apply. Learn more
      about <a href="http://www.w3.org/community/">W3C Community and Business
      Groups</a>.
    </p>
    <p>
      This report documents the use cases, requirements, examples, and other
      feedback on the general approach of the Presentation API as discussed in
      the Second Screen Presentation Community Group. Additionally, it
      documents the interfaces that represent an evolved version of the
      Presentation API to the extend discussed in the group. The <a href=
      "http://webscreens.github.io/presentation-api/20131112/">previous version
      of the Presentation API</a> was used as a starting point for this work.
    </p>
    <h2 class="no-num no-toc">
      Table of Contents
    </h2><!--toc-->
    <h2>
      Introduction
    </h2><em>This section is non-normative.</em>
    <p>
      This specification aims to make secondary displays such as a projector or
      a connected TV available to the web and takes into account displays that
      are attached using wired (HDMI, DVI or similar) and wireless technologies
      (MiraCast, Chromecast, DLNA, AirPlay or similar).
    </p>
    <p>
      Devices with limited screen size lack the ability to show content to a
      larger audience, for example a group of colleagues in a conference room,
      or friends and family at home. Showing content on an external large
      display helps to improve the perceived quality and impact of the
      presented content.
    </p>
    <h3 id="use-cases">
      Use Cases
    </h3>
    <h4>
      Presentations
    </h4>
    <p>
      A user is preparing a set of slides for a talk. Using a web based
      service, she is editing her slides and speaker notes on the primary
      screen, while the secondary larger screen shows a preview of the current
      slide. When the slides are done, her mobile phone allows her to access
      them from an online service while on the go. Coming to the conference,
      using wireless display technology, she would like to present her slides
      on the stage screen from her mobile phone. The phone's touch screen helps
      her to navigate slides and presents a slide preview, while the projector
      shows her slides to the audience.
    </p>
    <p>
      <b>Requirements:</b> R1, R3, R4, R5, R7
    </p>
    <h4>
      <a id="video-sharing">Video and Image Sharing</a>
    </h4>
    <p>
      Using an online video or image sharing service, a user would like to show
      memorable moments to her friends. Using a device with a small screen, it
      is impossible to show the content to a large group of people. Connecting
      an external TV screen or projector to her device - with a cable or
      wirelessly - the online sharing service now makes use of the connected
      display, allowing a wider audience to enjoy the content.
    </p>
    <p>
      The web page shows UI elements that allow the user to trigger displaying
      content on the secondary display (e.g a "send to second screen" ) only if
      there is at least one secondary screen available.
    </p>
    <p>
      <b>Requirements:</b> R1, R3, R4, R5, R7
    </p>
    <h4>
      Gaming
    </h4>
    <p>
      Splitting the gaming experience into a near screen controller and a large
      screen visual experience, new gaming experiences can be created.
      Accessing the local display on the small screen device and an external
      larger display allows for richer web-based gaming experiences.
    </p>
    <p>
      <b>Requirements:</b> R1, R3, R4, R5, R7
    </p>
    <h4>
      Media Flinging to Multiple Screens
    </h4>Alice enters a video sharing site using a browser on her tablet. Next,
    Alice picks her favorite video from the site, and the video starts to play
    on her tablet. While the video is playing Alice clicks a button "Share on
    different screen". The browser provides a user interface that lists all the
    screens Alice has around her home, asking her to select one. The screens
    are identified by names that are familiar to Alice. Alice picks one screen
    from the list, "Alice's big TV", and the video playback continues
    seamlessly on the selected screen. Next she decides to switch the playback
    to a different screen. She clicks the same button "Share on different
    screen" provided by the site, and the browser presents the user interface
    that lists all the screens. Alice picks another screen from the list,
    "Alice's kitchen TV", and the playback resumes on that screen. Video site
    also provides a feature to see the action (Alice is watching a soccer game)
    from different angle. Alice clicks a button "Select screen for additional
    angle", and the browser asks Alice similarly to select the screen to be
    used for playback. Alice picks "Alice's Projector" and the soccer game is
    shown on the projector from a different angle, in parallel to the content
    being played back on "Alice's kitchen TV".
    <p>
      <b>Requirements:</b> R1, R3, R4, R5, R6, R7
    </p>
    <h2>
      Requirements
    </h2>
    <h3>
      Functional Requirements
    </h3>
    <ul>
      <li>
        <b>Discovery / Availability</b>
        <ul>
          <li>R1: The UA must provide a way to find out whether at least one
          secondary screen is available.
          </li>
        </ul>
      </li>
    </ul>
    <p class="note">
      Multi-Screen enumeration and named identification removed, after
      discussion on the mailing list, cmp. <a rel="nofollow" class=
      "external free" href=
      "http://lists.w3.org/Archives/Public/public-webscreens/2014Feb/0021.html">
      http://lists.w3.org/Archives/Public/public-webscreens/2014Feb/0021.html</a>&nbsp;:
    </p>
    <ul>
      <li>
        <b>Launching Presentation</b>
        <ul>
          <li>R3: The UA must provide a means of start sending content to the
          secondary screen.
          </li>
        </ul>
      </li>
      <li>
        <b>Resuming Presentation</b>
        <ul>
          <li>R4: The UA must be able to resume an existing session with
          content being displayed on the secondary screen.
          </li>
        </ul>
      </li>
      <li>
        <b>Communication</b>
        <ul>
          <li>R5: The UA must enable exchanging data between the primary and
          the secondary screen in order to have a control channel between the
          primary and secondary page.
          </li>
          <li>R6: The UA must not make assumptions about the the execution
          locality of the user agent of the remote page it communicates with
          (i.e. the secondary page might run on a remote user agent and thus
          the link between the two pages' UA must be loosely coupled).
          </li>
        </ul>
      </li>
    </ul>
    <ul>
      <li>
        <b>Signaling Disconnection</b>
        <ul>
          <li>R7: The UA must signal disconnection from the presentation page
          to the primary page and vice versa.
          </li>
        </ul>
      </li>
    </ul>
    <h3>
      <span id="Non-Functional_Requirements">Non-Functional Requirements</span>
    </h3>
    <ul>
      <li>
        <b>Power Saving Friendly</b>
        <ul>
          <li>All API design decisions must be analyzed from a power efficiency
          point of view. Especially when using wireless display technologies or
          querying availability anything over a radio channel, care needs to be
          taken to design the API in a way that does not pose obstacles to
          using radio resources in an efficient way. For example, powering up
          the wireless display detection only when needed.
          </li>
        </ul>
      </li>
    </ul>
    <h2>
      Conformance
    </h2>
    <p>
      All diagrams, examples, and notes in this specification are
      non-normative, as are all sections explicitly marked non-normative.
      Everything else in this specification is normative.
    </p>
    <p>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in RFC
      2119. For readability, these words do not appear in all uppercase letters
      in this specification. <span data-anolis-ref="">RFC2119</span>
    </p>
    <p>
      Requirements phrased in the imperative as part of algorithms (such as
      "strip any leading space characters" or "return false and terminate these
      steps") are to be interpreted with the meaning of the key word ("must",
      "should", "may", etc.) used in introducing the algorithm.
    </p>
    <p>
      Conformance requirements phrased as algorithms or specific steps may be
      implemented in any manner, so long as the end result is equivalent. (In
      particular, the algorithms defined in this specification are intended to
      be easy to follow, and not intended to be performant.)
    </p>
    <h2>
      Terminology
    </h2>
    <p>
      The term <dfn title="presentation display">presentation display</dfn>
      refers to an external screen connected to the device that the user agent
      runs on.
    </p>
    <p>
      The terms <span title="opener-browsing-context" data-anolis-spec=
      "w3c-html">opener browsing context</span> and <span title=
      "auxiliary browsing context" data-anolis-spec="w3c-html">auxiliary
      browsing context</span> are defined in <span data-anolis-ref=
      "">HTML5</span>.
    </p>
    <p>
      The terms <span data-anolis-spec="w3c-html">event handlers</span> and
      <span title="event handler event type" data-anolis-spec="w3c-html">event
      handler event types</span> are defined in <span data-anolis-ref=
      "">HTML5</span>.
    </p>
    <p>
      This document provides interface definitions using the
      <span data-anolis-ref="">WEBIDL</span> standard.
    </p>
    <h2>
      Example
    </h2>
    <p>
      Running in a compliant user agent, code for presenting a page
      <code>example.html</code> on the presentation display looks as follows:
    </p>
    <pre class="example">
/* controller.html */

&lt;button disabled&gt;Show&lt;/button&gt;

&lt;script&gt;
var presentation = navigator.presentation,
    showButton = document.querySelector('button');
 
presentation.onavailablechange = function(e) {
  showButton.disabled = !e.available;
  showButton.onclick = show;
};
 
function show() {
  var session = presentation.requestSession('http://example.org/');
 
  session.onstatechange = function() {
    switch (session.state) {
      case 'connected':
        session.postMessage(/*...*/);
        session.onmessage = function() { /*...*/ };
        break;
      case 'disconnected':
        console.log('Disconnected.');
        break;
    }
  };
}
&lt;/script&gt;
</pre>
    <p>
      The availability monitoring for secondary screens begins when the page
      adds an event listener for the <code>availablechange</code> event on the
      <code>navigator.presentation</code> object. If there are already
      available screens when the page adds the first event listener for the
      event, the UA synthesizes a single availablechange event to signal the
      availability.
    </p>
    <p class="open-issue">
      Do we want to fire an event immediately after the page registers for it?
      What's a best practice method for asynchronous notifications of ths kind?
      See below in the <a href="#open-questions">Open Questions</a> section.
    </p>
    <p>
      The "Show" button's state (initially disabled) informs the user of the
      availability of secondary screen(s), and the button's state is updated if
      the availability changes. (The rationale of putting the actual boolean
      information into a property of the event <code>e.available</code> is to
      allow the implementation to optimize power consumption for network
      discovery of remote wireless screens. If this information was provided in
      a globally accessible flag, the network discovery could never be
      suspended for keeping the flag up to date.)
    </p>
    <p>
      Once the user clicks the "Show" button, the <code>show()</code> function
      is called.
    </p>
    <p>
      By calling <code>navigator.presentation.requestSession(url)</code>, the
      script on the page tries to launch or resume a presentation on a
      secondary screen. Based on the <code>url</code> argument, the UA looks
      for existing sessions and available screens, and presents a screen picker
      user interface to the user. Out of the list of existing sessions or
      available screens the user selects one item. If an existing session was
      selected, the session is resumed by establishing a communication channel.
      If a new screen was selected, the UA connects to the selected screen,
      brings up a new window on the selected screen, starts to show the content
      denoted by the url argument, and the UA establishes a communication
      channel with this window.
    </p>
    <p>
      When the <code>navigator.presentation.requestSession(url)</code> function
      is called, the UA immediately returns a <code>session</code> object to
      the script which represents a handle to the current presentation session,
      used for communication and state handling.
    </p>
    <p>
      If the user has selected a screen, the content is shown and a
      communication channel was established, the state of the session object
      changes from <code>"disconnected"</code> to <code>"connected"</code>,
      which signals the presentation session is up and running, and the opener
      page can communicate with the presentation page. For communication with
      the presentation page, the session object's <code>postMessage()</code> is
      used to send, and the <code>onmessage</code> event handler to receive
      messages.
    </p>
    <p>
      If the user cancels the screen selection and never selects a screen, no
      state transition happens and the <code>session</code> object remains in
      the <code>"disconnected"</code> state.
    </p>
    <h4>
      Open Questions
    </h4>
    <p class="open-issue">
      Do we need to insert into the description an additional permission prompt
      to grant the page access to the "one ore more screens are available"
      Information?
    </p>
    <p class="open-issue">
      If there are already connected screens when the page subscribes to the
      <code>onavailablechange</code> event, we can handle this in two ways: We
      can synthesize one initial event to notify the page about available
      screens as soon as the first event handler is installed (as described).
      Or we can add another message like
      <code>navigator.presentation.getAvailable(function(available) { }
      );</code> to notify the page about available screens using this one-time
      asynchronous getter. Which way should we go?
    </p>
    <p class="open-issue">
      Do we need an additional state like resumed in order to identify resumed
      session? It seems that this could be handled on the page level. The
      opener page could ask the presentation page whether it is
      <code>"new"</code> or <code>"resumed"</code>.
    </p>
    <h3>
      Usage on Remote Screen
    </h3>For addressing the requirement of communication between originating
    page and presentation page/screen, we can now use the same
    <code>session</code> object on the remote side.
    <pre class="example">
navigator.presentation.onpresent = function(e) {
  // Communicate with opener page.
  e.session.postMessage(/*...*/);
  e.session.onmessage = function() {/*...*/};

  e.session.onstatechange = function() {
    switch (this.state) {
      case "disconnected":
        // Handle disconnection from opener page.
    }
  };
};
</pre>
    <p>
      When the content denoted by the url argument in the
      <code>requestSession()</code> example above is loaded, the page on the
      presentation screen receives a <code>PresentEvent</code>, with a
      <code>session</code> property representing the session. This session is a
      similar object as in the first example. Here, its initial state is
      <code>"connected"</code>, which means we can use it to communicate with
      the opener page using <code>postMessage()</code> and
      <code>onmessage</code>.
    </p>
    <p>
      We can also monitor the connection state by listening for
      <code>statechange</code> events. When the state changes to
      <code>"disconnected"</code> the page is made aware of the fact that
      communication with the opener page was lost, but it can continue to
      display the current content. The communication can be re-established when
      a new present event fires on the <code>navigator.presentation</code>
      object.
    </p>
    <h2>
      Interfaces
    </h2>
    <p>
      The interfaces described herein address the requirements outlined in the
      <a href="#use-cases">Use Cases</a> section, and specifically, also
      consider the <a href="#media-flinging-to-multiple-screens">Media Flinging
      to Multiple Screens</a> use case unaddressed by the <a href=
      "#previous-version">previous version of the Presentation API</a>. This
      section describes the interfaces to the extend discussed in the Second
      Screen Presentation Community Group. Readers are encouraged to consult
      the <a href="#example">Example</a> section together with this section for
      a more complete understanding of the technical parts of this
      specification.
    </p>
    <h3>
      <code>NavigatorPresentation</code>
    </h3>
    <pre class="idl">
interface NavigatorPresentation : EventTarget {
  PresentationSession requestSession(DOMString url);
  attribute EventHandler onavailablechange;
  attribute EventHandler onpresent;
};

partial interface Navigator {
  readonly attribute NavigatorPresentation presentation;
};
</pre>
    <h3>
      <code>AvailableChangeEvent</code>
    </h3>
    <p>
      Fired at the primary screen's <code>NavigatorPresentation</code> object,
      when screen availability changes.
    </p>
    <pre class="idl">
[Constructor(DOMString type, optional AvailableChangeEventInit eventInitDict)]
interface AvailableChangeEvent : Event {
  readonly attribute boolean available;
};

dictionary AvailableChangeEventInit : EventInit {
  boolean available;
};
</pre>
    <h3>
      <code>PresentEvent</code>
    </h3>Fired at the secondary screen's <code>NavigatorPresentation</code>
    object, when the presentation session is established.
    <pre class="idl">
[Constructor(DOMString type, optional PresentEventInit eventInitDict)]
interface PresentEvent : Event {
  readonly attribute PresentationSession session;
};

dictionary PresentEventInit : EventInit {
  PresentationSession session;
};
</pre>
    <h3>
      <code>PresentationSession</code>
    </h3>
    <p>
      An object representing the established presentation session.
    </p>
    <pre class="idl">
enum PresentationSessionState { "connected", "disconnected" /*, "resumed" */ };

interface PresentationSession : EventTarget {
  readonly attribute PresentationSessionState state;
  void postMessage(DOMString message);
  void close();
  attribute EventHandler onmessage;
  attribute EventHandler onstatechange;
};
</pre>
    <h2 class="no-num">
      References
    </h2>
    <div id="anolis-references"></div>
    <h2 class="no-num">
      Acknowledgements
    </h2>
    <p>
      Thanks to Wayne Carr, Louay Bassbous, Anssi Kostiainen, 闵洪波 (Hongbo Min),
      Anton Vayvod for help with editing, reviews and feedback to this draft.
    </p>
  </body>
</html>
