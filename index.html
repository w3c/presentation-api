<!DOCTYPE html><html lang="en-US"><head>
    <meta charset="UTF-8">
    <title>
      Presentation API
    </title>
    <style>
@media print {
     [data-anolis-spec]::after { content:"[" attr(data-anolis-spec) "]"; font-size:.6em; vertical-align:super; text-transform:uppercase }
    }
    </style>
    <link href="http://www.w3.org/StyleSheets/TR/W3C-ED" rel="stylesheet" type="text/css">
    <style type="text/css">
/* Note formatting taken from HTML5 spec */
    .note { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #E9FBE9; border-color: #52E052; }
    .note em, .warning em, .note i, .warning i { font-style: normal; }
    p.note, div.note { padding: 0.5em 2em; }
    span.note { padding: 0 2em; }
    .note p:first-child { margin-top: 0; }
    .note p:last-child { margin-bottom: 0; }
    p.note:before { content: 'Note: '; font-weight: bolder;}

    .open-issue { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #fbfbe9; border-color: #faf9a5; }
    .open-issue em, .warning em, .open-issue i, .warning i { font-style: normal; }
    p.open-issue, div.open-issue { padding: 0.5em 2em; }
    span.open-issue { padding: 0 2em; }
    .open-issue p:first-child { margin-top: 0; }
    .open-issue p:last-child { margin-bottom: 0; }
    p.open-issue:before { content: 'Open issue: '; font-weight: bolder;}

    .non-normative { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #E9FBE9; border-color: #52E052; }
    p.non-normative:before { content: 'Non-normative: '; font-weight: bolder;}
    p.non-normative, div.non-normative { padding: 0.5em 2em; }


    /* Pre.idl formatting taken from HTML5 spec */
    pre.idl { border: solid thin #d3d3d3; background: #FCFCFC; color: black; padding: 0.5em 1em; position: relative; }
    pre.idl :link, pre.idl :visited { color: inherit; background: transparent; }
    pre.idl::before { content: "IDL"; font: bold small sans-serif;
    padding: 0.5em; background: white; position: absolute; top: 0;
    margin: -1px 0 0 -4em; width: 1.5em; border: thin solid;
    border-radius: 0 0 0 0.5em }

    /* .example idl formatting taken from HTML5 nightly spec */
    .example {
        display: block;
        color: #222222;
        background: #FCFCFC;
        border-left-style: solid;
        border-color: #c0c0c0;
        border-left-width: 0.25em;
        margin-left: 1em;
        padding-left: 1em;
        padding-bottom: 0.5em;
    }

    .algorithm li {
        margin-bottom: 0.5em;
    }

    .interface dd, .parameters dt {
        margin-bottom: 0.5em;
    }

    code { color: orangered; }
    </style>
  </head>
  <body>
    <div class="head">
      
<!--begin-logo-->
<p><a href="http://www.w3.org/"><img alt="W3C" height="48" src="https://www.w3.org/Icons/w3c_home" width="72"></a></p>
<!--end-logo-->
      <h1>
        Presentation API
      </h1>
      <h2 class="no-num no-toc" id="w3c-editor's-draft-19-november-2014">
        W3C Editor's Draft 19 November 2014
      </h2>
      <dl>
        <dt>
          This Version:
        </dt>
        <dd>
          <!--begin-link--><a href="http://w3c.github.io/presentation-api/ 
          ">http://w3c.github.io/presentation-api/ 
          </a><!--end-link-->
        </dd>
        <dt>
          Latest Published Version:
        </dt>
        <dd>
          <!--begin-link--><a href="http://www.w3.org/TR/presentation-api/ 
          ">http://www.w3.org/TR/presentation-api/ 
          </a><!--end-link-->
        </dd>
        <dt>
          Latest Editor's Draft:
        </dt>
        <dd>
          <!--begin-link--><a href="http://w3c.github.io/presentation-api/ 
          ">http://w3c.github.io/presentation-api/ 
          </a><!--end-link-->
        </dd>
        <dt>
          Version History:
        </dt>
        <dd>
          <!--begin-link--><a href="https://github.com/w3c/presentation-api/commits/ 
          ">https://github.com/w3c/presentation-api/commits/ 
          </a><!--end-link-->
        </dd>
        <dt>
          Participate:
        </dt>
        <dd>
          Send feedback to the Working Group's mailing list <a href="https://lists.w3.org/Archives/Public/public-secondscreen/">public-secondscreen@w3.org</a>,
          or <a href="https://github.com/w3c/presentation-api/issues">create or
          browse open issues</a> on GitHub. Also, you may join on the <a href="irc://irc.w3.org:6665/#webscreens">WG's IRC channel</a>.
        </dd>
        <dt>
          Editor:
        </dt>
        <dd>
          <a href="mailto:dominik.rottsches@intel.com">Dominik Röttsches</a>,
          Intel
        </dd>
      </dl>
      <p class="copyright">
        <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>
        © 2014 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>,
        <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved.
        <abbr title="World Wide Web Consortium">W3C</abbr> <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
        <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
        and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document
        use</a> rules apply.
      </p>
      <hr>
    </div>
    <h2 class="no-num no-toc" id="abstract">
      Abstract
    </h2>
    <p>
      This specification defines an API to enable web content to access
      external presentation-type displays and use them for presenting web
      content.
    </p>
    <h2 class="no-num no-toc" id="sotd">
      Status of This Document
    </h2>
    <p>
      <em>This section describes the status of this document at the time of its
      publication. Other documents may supersede this document. A list of
      current W3C publications and the latest revision of this technical report
      can be found in the <a href="http://www.w3.org/TR/">W3C technical reports
      index</a> at http://www.w3.org/TR/.</em>
    </p>
    <p>
      This document was published by the <a href="http://www.w3.org/2014/secondscreen/">Second Screen Presentation Working
      Group</a> as an Editor's Draft. If you wish to make comments regarding
      this document, please send them to <a href="mailto:public-secondscreen@w3.org">public-secondscreen@w3.org</a>
      (<a href="mailto:public-secondscreen-request@w3.org?subject=subscribe">subscribe</a>,
      <a href="http://lists.w3.org/Archives/Public/public-secondscreen/">archives</a>).
      All comments are welcome.
    </p>
    <p>
      Publication as an Editor's Draft does not imply endorsement by the
      <abbr title="World Wide Web Consortium">W3C</abbr> Membership. This is a
      draft document and may be updated, replaced or obsoleted by other
      documents at any time. It is inappropriate to cite this document as other
      than work in progress.
    </p>
    <p>
      This document was produced by a group operating under the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/" id="sotd_patent" rel="w3p:patentRules">5 February 2004
      <abbr title="World Wide Web Consortium">W3C</abbr> Patent Policy</a>.
      <abbr title="World Wide Web Consortium">W3C</abbr> maintains a <a href="http://www.w3.org/2004/01/pp-impl/74168/status" rel="disclosure">public
      list of any patent disclosures</a> made in connection with the
      deliverables of the group; that page also includes instructions for
      disclosing a patent. An individual who has actual knowledge of a patent
      which the individual believes contains <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential
      Claim(s)</a> must disclose the information in accordance with <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section
      6 of the <abbr title="World Wide Web Consortium">W3C</abbr> Patent
      Policy</a>.
    </p>
    <p>
      This document is governed by the <a href="http://www.w3.org/2014/Process-20140801/" id="w3c_process_revision">1 August 2014 <abbr title="World Wide Web Consortium">W3C</abbr> Process Document</a>.
    </p>
    <h2 class="no-num no-toc" id="table-of-contents">
      Table of Contents
    </h2>
<!--begin-toc-->
<ol class="toc">
 <li><a href="#introduction"><span class="secno">1 </span>
      Introduction
    </a>
  <ol>
   <li><a href="#use-cases"><span class="secno">1.1 </span>
      Use Cases
    </a>
    <ol>
     <li><a href="#presentations"><span class="secno">1.1.1 </span>
      Presentations
    </a></li>
     <li><a href="#video-and-image-sharing"><span class="secno">1.1.2 </span>
      Video and Image Sharing
    </a></li>
     <li><a href="#gaming"><span class="secno">1.1.3 </span>
      Gaming
    </a></li>
     <li><a href="#media-flinging-to-multiple-screens"><span class="secno">1.1.4 </span>
      Media Flinging to Multiple Screens
    </a></ol></ol></li>
 <li><a href="#requirements"><span class="secno">2 </span>
      Requirements
    </a>
  <ol>
   <li><a href="#functional-requirements"><span class="secno">2.1 </span>
      Functional Requirements
    </a></li>
   <li><a href="#non-functional-requirements"><span class="secno">2.2 </span>
      <span>Non-Functional Requirements</span>
    </a></ol></li>
 <li><a href="#conformance"><span class="secno">3 </span>
      Conformance
    </a></li>
 <li><a href="#terminology"><span class="secno">4 </span>
      Terminology
    </a></li>
 <li><a href="#example"><span class="secno">5 </span>
      Example
    </a>
  <ol>
   <li><a href="#starting-new-presentations-or-manually-connecting-to-existing-presentations"><span class="secno">5.1 </span>
      Starting new presentations or manually connecting to existing
      presentations
    </a></li>
   <li><a href="#automatically-reconnecting-to-existing-presentations"><span class="secno">5.2 </span>
      Automatically reconnecting to existing presentations
    </a></li>
   <li><a href="#open-questions"><span class="secno">5.3 </span>
      Open Questions
    </a></li>
   <li><a href="#usage-on-remote-screen"><span class="secno">5.4 </span>
      Usage on Remote Screen
    </a></ol></li>
 <li><a href="#interfaces"><span class="secno">6 </span>
      Interfaces
    </a>
  <ol>
   <li><a href="#navigatorpresentation"><span class="secno">6.1 </span>
      <code>NavigatorPresentation</code>
    </a></li>
   <li><a href="#availablechangeevent"><span class="secno">6.2 </span>
      <code>AvailableChangeEvent</code>
    </a></li>
   <li><a href="#presentationsession"><span class="secno">6.3 </span>
      <code>PresentationSession</code>
    </a></ol></li>
 <li><a href="#algorithms"><span class="secno">7 </span>
      Algorithms
    </a>
  <ol>
   <li><a href="#screen-availability-listener-added"><span class="secno">7.1 </span>
      Screen Availability Listener Added
    </a></li>
   <li><a href="#screen-availability-listener-removed"><span class="secno">7.2 </span>
      Screen Availability Listener Removed
    </a></li>
   <li><a href="#no-screens-available"><span class="secno">7.3 </span>
      No Screens Available
    </a></li>
   <li><a href="#start-session"><span class="secno">7.4 </span>
      Start Session
    </a></li>
   <li><a href="#join-session"><span class="secno">7.5 </span>
      Join Session
    </a></li>
   <li><a href="#session-close"><span class="secno">7.6 </span>
      Session Close
    </a></li>
   <li><a href="#presentation-connection"><span class="secno">7.7 </span>
      Presentation Connection
    </a></li>
   <li><a href="#todo"><span class="secno">7.8 </span>
      TODO
    </a></ol></li>
 <li><a class="no-num" href="#references">
      References
    </a></li>
 <li><a class="no-num" href="#acknowledgments">
      Acknowledgments
    </a></ol>
<!--end-toc-->
    <h2 id="introduction"><span class="secno">1 </span>
      Introduction
    </h2><em>This section is non-normative.</em>
    <p>
      This specification aims to make secondary displays such as a projector or
      a connected TV available to the web and takes into account displays that
      are attached using wired (HDMI, DVI or similar) and wireless technologies
      (MiraCast, Chromecast, DLNA, AirPlay or similar).
    </p>
    <p>
      Devices with limited screen size lack the ability to show content to a
      larger audience, for example a group of colleagues in a conference room,
      or friends and family at home. Showing content on an external large
      display helps to improve the perceived quality and impact of the
      presented content.
    </p>
    <p>
      At its core, this specification enables an exchange of messages between a
      requesting page and a presentation page shown in the secondary display.
      How those messages are transmitted is left to the UA in order to allow
      for use of display devices that can be attached in a wide variety of
      ways. For example, when a display device is attached using HDMI or
      MiraCast, the UA on the requesting device can render the requested
      presentation page in that same UA, but instead of displaying in a window
      on that same device, it can use whatever means the operating system
      provides for using those external displays. In that case, both the
      requesting page and the presentation page run on the requesting device
      and the operating system is used to route the presentation display output
      to the other display device. The second display device doesn't need to
      know anything about this spec or that the content involves HTML5.
    </p>
    <p>
      Alternately, some types of external displays may be able to render HTML5
      themselves and may have defined their own way to send messages to that
      content. In that case, the UA on the requesting device would not need to
      render the presentation page itself. Instead, the UA could act as a proxy
      translating the request to show a page and the messages into the form
      understood by the display device.
    </p>
    <p>
      This way of attaching to displays could be enhanced in the future through
      definition of a standard protocol for delivering these types of messages
      that display devices could choose to implement.
    </p>
    <p>
      The API defined here is intended be used with UAs that attach to display
      devices through any of the above means.
    </p>
    <h3 id="use-cases"><span class="secno">1.1 </span>
      Use Cases
    </h3>
    <h4 id="presentations"><span class="secno">1.1.1 </span>
      Presentations
    </h4>
    <p>
      A user is preparing a set of slides for a talk. Using a web based
      service, she is editing her slides and speaker notes on the primary
      screen, while the secondary larger screen shows a preview of the current
      slide. When the slides are done, her mobile phone allows her to access
      them from an online service while on the go. Coming to the conference,
      using wireless display technology, she would like to present her slides
      on the stage screen from her mobile phone. The phone's touch screen helps
      her to navigate slides and presents a slide preview, while the projector
      shows her slides to the audience.
    </p>
    <p>
      <b>Requirements:</b> R1, R3, R4, R5, R7
    </p>
    <h4 id="video-and-image-sharing"><span class="secno">1.1.2 </span>
      <a id="video-sharing">Video and Image Sharing</a>
    </h4>
    <p>
      Using an online video or image sharing service, a user would like to show
      memorable moments to her friends. Using a device with a small screen, it
      is impossible to show the content to a large group of people. Connecting
      an external TV screen or projector to her device - with a cable or
      wirelessly - the online sharing service now makes use of the connected
      display, allowing a wider audience to enjoy the content.
    </p>
    <p>
      The web page shows UI elements that allow the user to trigger displaying
      content on the secondary display (e.g a "send to second screen" ) only if
      there is at least one secondary screen available.
    </p>
    <p>
      <b>Requirements:</b> R1, R3, R4, R5, R7
    </p>
    <h4 id="gaming"><span class="secno">1.1.3 </span>
      Gaming
    </h4>
    <p>
      Splitting the gaming experience into a near screen controller and a large
      screen visual experience, new gaming experiences can be created.
      Accessing the local display on the small screen device and an external
      larger display allows for richer web-based gaming experiences.
    </p>
    <p>
      <b>Requirements:</b> R1, R3, R4, R5, R7
    </p>
    <h4 id="media-flinging-to-multiple-screens"><span class="secno">1.1.4 </span>
      Media Flinging to Multiple Screens
    </h4>Alice enters a video sharing site using a browser on her tablet. Next,
    Alice picks her favorite video from the site, and the video starts to play
    on her tablet. While the video is playing Alice clicks a button "Share on
    different screen". The browser provides a user interface that lists all the
    screens Alice has around her home, asking her to select one. The screens
    are identified by names that are familiar to Alice. Alice picks one screen
    from the list, "Alice's big TV", and the video playback continues
    seamlessly on the selected screen. Next she decides to switch the playback
    to a different screen. She clicks the same button "Share on different
    screen" provided by the site, and the browser presents the user interface
    that lists all the screens. Alice picks another screen from the list,
    "Alice's kitchen TV", and the playback resumes on that screen. Video site
    also provides a feature to see the action (Alice is watching a soccer game)
    from different angle. Alice clicks a button "Select screen for additional
    angle", and the browser asks Alice similarly to select the screen to be
    used for playback. Alice picks "Alice's Projector" and the soccer game is
    shown on the projector from a different angle, in parallel to the content
    being played back on "Alice's kitchen TV".
    <p>
      <b>Requirements:</b> R1, R3, R4, R5, R6, R7
    </p>
    <h2 id="requirements"><span class="secno">2 </span>
      Requirements
    </h2>
    <h3 id="functional-requirements"><span class="secno">2.1 </span>
      Functional Requirements
    </h3>
    <ul>
      <li>
        <b>Discovery / Availability</b>
        <ul>
          <li>R1: The UA must provide a way to find out whether at least one
          secondary screen is available.
          </li>
        </ul>
      </li>
    </ul>
    <p class="note">
      Multi-Screen enumeration and named identification removed, after
      discussion on the mailing list, cmp. <a class="external free" href="http://lists.w3.org/Archives/Public/public-webscreens/2014Feb/0021.html" rel="nofollow">
      http://lists.w3.org/Archives/Public/public-webscreens/2014Feb/0021.html</a> :
    </p>
    <ul>
      <li>
        <b>Launching Presentation</b>
        <ul>
          <li>R3: The UA must provide a means of start sending content to the
          secondary screen.
          </li>
        </ul>
      </li>
      <li>
        <b>Resuming Presentation</b>
        <ul>
          <li>R4: The UA must be able to resume an existing session with
          content being displayed on the secondary screen.
          </li>
        </ul>
      </li>
      <li>
        <b>Communication</b>
        <ul>
          <li>R5: The UA must enable exchanging data between the primary and
          the secondary screen in order to have a control channel between the
          primary and secondary page.
          </li>
          <li>R6: The UA must not make assumptions about the the execution
          locality of the user agent of the remote page it communicates with
          (i.e. the secondary page might run on a remote user agent and thus
          the link between the two pages' UA must be loosely coupled).
          </li>
        </ul>
      </li>
    </ul>
    <ul>
      <li>
        <b>Signaling Disconnection</b>
        <ul>
          <li>R7: The UA must signal disconnection from the presentation page
          to the primary page and vice versa.
          </li>
        </ul>
      </li>
    </ul>
    <h3 id="non-functional-requirements"><span class="secno">2.2 </span>
      <span id="Non-Functional_Requirements">Non-Functional Requirements</span>
    </h3>
    <ul>
      <li>
        <b>Power Saving Friendly</b>
        <ul>
          <li>All API design decisions must be analyzed from a power efficiency
          point of view. Especially when using wireless display technologies or
          querying availability over a radio channel, care needs to be taken to
          design the API in a way that does not pose obstacles to using radio
          resources in an efficient way. For example, powering up the wireless
          display detection only when needed.
          </li>
        </ul>
      </li>
    </ul>
    <h2 id="conformance"><span class="secno">3 </span>
      Conformance
    </h2>
    <p>
      All diagrams, examples, and notes in this specification are
      non-normative, as are all sections explicitly marked non-normative.
      Everything else in this specification is normative.
    </p>
    <p>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in RFC
      2119. For readability, these words do not appear in all uppercase letters
      in this specification. <a href="#refsRFC2119">[RFC2119]</a>
    </p>
    <p>
      Requirements phrased in the imperative as part of algorithms (such as
      "strip any leading space characters" or "return false and terminate these
      steps") are to be interpreted with the meaning of the key word ("must",
      "should", "may", etc.) used in introducing the algorithm.
    </p>
    <p>
      Conformance requirements phrased as algorithms or specific steps may be
      implemented in any manner, so long as the end result is equivalent. (In
      particular, the algorithms defined in this specification are intended to
      be easy to follow, and not intended to be performant.)
    </p>
    <h2 id="terminology"><span class="secno">4 </span>
      Terminology
    </h2>
    <p>
      The term <dfn id="presentation-display" title="presentation display">presentation display</dfn>
      refers to an external screen connected to the device that the user agent
      runs on.
    </p><!--    <p>
      The terms <span title="opener-browsing-context" data-anolis-spec=
      "w3c-html">opener browsing context</span> and <span title=
      "auxiliary browsing context" data-anolis-spec="w3c-html">auxiliary
      browsing context</span> are defined in <span data-anolis-ref=
      "">HTML5</span>.
    </p>
-->
    <p>
      The terms <a class="external" data-anolis-spec="w3c-html" href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#event-handlers">event handlers</a> and
      <a class="external" data-anolis-spec="w3c-html" href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#event-handler-event-type" title="event handler event type">event
      handler event types</a> are defined in <a href="#refsHTML5">[HTML5]</a>.
    </p>
    <p>
      This document provides interface definitions using the
      <a href="#refsWEBIDL">[WEBIDL]</a> standard.
    </p>
    <h2 id="example"><span class="secno">5 </span>
      Example
    </h2>
    <p>
      Running in a compliant user agent, code for presenting a page
      <code>http://example.org/presentation.html</code> on the presentation
      display looks as follows:
    </p>
    <pre class="example">/* controller.html */

&lt;button disabled id=show&gt;Show&lt;/button&gt;
&lt;button disabled id=stop&gt;Stop&lt;/button&gt;

&lt;script&gt;

var presentation = navigator.presentation,
    showButton = document.getElementById('show'),
    stopButton = document.getElementById('stop');

var session = null;
var screenAvailable = false;
var presentationUrl = 'http://example.org/presentation.html';
var presentationId = localStorage['presentationId'] ||
    new String((Math.random() * 10000).toFixed(0));

// Join an existing presentation if one exists.
presentation.joinSession(presentationUrl, presentationId).then(
    function(existingSession) {
      setSession(existingSession);
      updateButtons();
    },
    function() {
      // No session to join.
    });

presentation.onavailablechange = function(e) {
  screenAvailable = e.available;
  updateButtons();
};

function updateButtons() {
  stopButton.disabled = !session;
  stopButton.onClick = session ? stopPresent : null;
  showButton.disabled = !screenAvailable;
  showButton.onclick = screenAvailable ? startPresent : null;
};

function startPresent() {
  presentation.startSession(presentationUrl, presentationId).then(
      function(newSession) {
        setSession(newSession);
        updateButtons();
      },
      function() {
        // User cancelled, etc.
      });
};

function stopPresent() {
  if (!session) return;
  session.close();
  delete localStorage['presentationId'];
};

function setSession(theSession) {
  // NOTE: We could instead close the current session.
  if (session) return;
  session = theSession;
  localStorage['presentationId'] = session.id;
  session.onstatechange = function() {
    switch (session.state) {
      case 'connected':
        session.postMessage(/*...*/);
        session.onmessage = function() { /*...*/ };
        break;
      case 'disconnected':
        console.log('Disconnected.');
        break;
    }
  };
}
&lt;/script&gt;
</pre>
    <p class="open-issue">
      We could simplify the example, and perhaps remove UI button state
      management for the sake of clarity.
    </p>
    <p>
      The availability monitoring for secondary screens begins when the page
      adds an event listener for the <code>availablechange</code> event on the
      <code>navigator.presentation</code> object. If there are already
      available screens when the page adds the first event listener for the
      event, the UA synthesizes a single <code>availablechange</code> event to
      signal the availability.
    </p>
    <p class="open-issue">
      Do we want to fire an event immediately after the page registers for it?
      What's a best practice method for asynchronous notifications of this
      kind? See below in the <a href="#open-questions">Open Questions</a>
      section.
    </p>
    <p class="open-issue">
      It is an open issue whether to provide filter information as part of the
      request for notification of available screens. This could be useful when
      a particular application or capability is needed in order to display the
      contents of a presentation. One possible approach to this could be to
      provide the URL for the presentation and / or required options as part of
      the request for notification of available screens. If this was supported,
      only screens that satisfied the filter would trigger a notification.
    </p>
    <h4 id="starting-new-presentations-or-manually-connecting-to-existing-presentations"><span class="secno">5.1 </span>
      Starting new presentations or manually connecting to existing
      presentations
    </h4>
    <p>
      The "Show" button's state (initially disabled) informs the user of the
      availability of secondary screen(s), and the button's state is updated if
      the availability changes. (The rationale of putting the actual boolean
      information into a property of the event <code>e.available</code> is to
      allow the implementation to optimize power consumption for network
      discovery of remote wireless screens. If this information was provided in
      a globally accessible flag, the network discovery could never be
      suspended for keeping the flag up to date.)
    </p>
    <p>
      Clicking the "Show" button calls
      <code>navigator.presentation.startSession()</code>, which causes the user
      agent to request from the user a screen to show the presentation. The
      <code>url</code> argument indicates the content to be presented. The
      <code>presentationId</code> argument (optional) allows the page to
      identify this presentation instance, and control which other pages may
      connect to it by setting a hard-to-guess id.
    </p>
    <p class="open-issue">
      As previously discussed on the mailing list - we can add convenience here
      by default-generating an ID.
    </p>
    <p>
      If the user selects a screen with an existing presentation showing the
      same <code>url</code> under the same <code>presentationId</code>, the
      opener page is connected to that existing presentation. If the user
      selects a screen without an existing presentation, or a screen presenting
      a different <code>url</code> or <code>presentationId</code>, the UA
      connects to the selected screen, brings up a new presentation window on
      it, and starts to show the content denoted by the <code>url</code>
      argument. The UA then connects the opener page to this new presentation
      and allows the opener page to exchange messages with it.
    </p>
    <p>
      <code>navigator.presentation.startSession(url, presentationId)</code>
      returns a <code>Promise</code> to the opener page. When the user selects
      a screen, the presentation page is shown and a communication channel has
      been established the <code>Promise</code> resolves to a
      <code>PresentationSession</code> object, which acts as a handle to the
      presentation for communication and state handling. Initially, the state
      of the <code>PresentationSession</code> is <code>"connected"</code>. At
      this point, the opener page can communicate with the presentation page
      using the session's <code>postMessage()</code> to send messages and its
      <code>onmessage</code> event handler to receive messages. The
      presentation page will also have access to
      <code>PresentationSession</code> that it can use to send and receive
      messages with the opener page (see <a href="#usage-on-remote-screen">Usage on Remote Screen</a>).
    </p>
    <p>
      If the user cancels screen selection, the <code>Promise</code> returned
      by <code>startSession(url, presentationId)</code> remains unresolved.
    </p>
    <p>
      While there is a pending call to <code>startSession</code> asking the
      user to select a screen (that the user has not yet accepted or canceled),
      the browser may choose to reject subsequent calls to
      <code>startSession</code> from the same page, by returning a
      <code>Promise</code> that never resolves. This will prevent the browser
      from needing to 'queue up' requests to present to the user.
    </p>
    <h4 id="automatically-reconnecting-to-existing-presentations"><span class="secno">5.2 </span>
      Automatically reconnecting to existing presentations
    </h4>
    <p>
      The opener page may wish to reconnect to an existing presentation without
      prompting the user to select a screen. For example, the site could allow
      media items from different pages to be shown on the same presentation
      page, and does not want to prompt the user on each page to reconnect to
      that presentation. To reconnect automatically, the page may call
      <code>joinSession(url, presentationId)</code>, which returns a
      <code>Promise</code> that resolves to an existing
      <code>PresentationSession</code> if one exists that is presenting the
      same <code>url</code> with the same <code>presentationId</code> as was
      passed originally into <code>startSession</code>. The requesting page can
      then communicate with the presentation as if the user had manually
      connected to it via <code>startSession</code>.
    </p>
    <p>
      At the time <code>joinSession(url, presentationId)</code> is called, if
      the browser is not aware of any <code>PresentationSession</code> with a
      matching <code>url</code> and <code>presentationId</code>, the
      <code>Promise</code> should remain unresolved. The browser may become
      aware of such a session at a later time (for example, by switching to a
      WiFi network that has a screen showing that URL). In this case, the
      browser may resolve the Promise to allow the page to connect to the
      running session.
    </p>
    <p class="open-issue">
      Do we want to keep the Promise in pending state?
    </p>
    <p>
      If the browser knows of multiple matching sessions, it should connect the
      page to the session that was most recently connected to; if that cannot
      be determined by the browser (for example, if the matching sessions have
      never been connected), then the <code>Promise</code> should remain
      unresolved.
    </p>
    <p>
      If the page calls <code>startSession(url, presentationId)</code> and
      there is a pending <code>Promise</code> from a call to
      <code>joinSession(url, presentationId)</code> (with the same
      <code>url</code> and <code>presentationId</code>, and the user selects a
      screen in response to <code>startSession</code>, then the
      <code>Promise</code> from <code>startSession</code> will be resolved and
      the <code>Promise</code> from <code>joinSession</code> will not.
    </p>
    <h4 id="open-questions"><span class="secno">5.3 </span>
      Open Questions
    </h4>
    <p class="open-issue">
      Do we need to insert into the description an additional permission prompt
      to grant the page access to the "one ore more screens are available"
      Information?
    </p>
    <p class="open-issue">
      If there are already connected screens when the page subscribes to the
      <code>onavailablechange</code> event, we can handle this in two ways: We
      can synthesize one initial event to notify the page about available
      screens as soon as the first event handler is installed (as described).
      Or we can add another message like
      <code>navigator.presentation.getAvailable(function(available) { }
      );</code> to notify the page about available screens using this one-time
      asynchronous getter. Which way should we go?
    </p>
    <p class="open-issue">
      Do we need an additional state like resumed in order to identify resumed
      session? It seems that this could be handled on the page level. The
      opener page could ask the presentation page whether it is
      <code>"new"</code> or <code>"resumed"</code>.
    </p>
    <h3 id="usage-on-remote-screen"><span class="secno">5.4 </span>
      Usage on Remote Screen
    </h3>
    <p>
      For addressing the requirement of communication between originating page
      and presentation page/screen, the presenting page can now use the same
      <code>session</code> object. It accesses this object through the
      <code>navigator.presentation.session</code> property, which is only
      non-<code>null</code> for the page on the presentation screen.
    </p>
    <pre class="example">if (navigator.presentation.session) {
  var session = navigator.presentation.session;
  // Communicate with opener page.
  session.postMessage(/*...*/);
  session.onmessage = function() {/*...*/};

  session.onstatechange = function() {
    switch (this.state) {
      case "disconnected":
        // Handle disconnection from opener page.
    }
  };
};
</pre>
    <p>
      When the content denoted by the <code>url</code> argument in the
      <code>startSession()</code> example above is loaded, the page on the
      presentation screen will have its
      <code>navigator.presentation.session</code> property set to the session.
      This session is a similar object as in the first example. Here, its
      initial state is <code>"connected"</code>, which means we can use it to
      communicate with the opener page using <code>postMessage()</code> and
      <code>onmessage</code>.
    </p>
    <p>
      The presentation page can also monitor the connection state by listening
      for <code>statechange</code> events. When the state changes to
      <code>"disconnected"</code> the page is made aware of the fact that
      communication with the opener page was lost, but it can continue to
      display the current content. The communication can be re-established when
      a <code>statechange</code> event fires with a new state of
      <code>"connected"</code>.
    </p>
    <p class="open-issue">
      Since we permit multiple opener pages to connect the same presentation
      page, we need to define how connection and disconnection of these pages
      is communicated to the presentation page (if at all).
    </p>
    <h2 id="interfaces"><span class="secno">6 </span>
      Interfaces
    </h2>
    <p>
      The interfaces described herein address the requirements outlined in the
      <a href="#use-cases">Use Cases</a> section, and specifically, also
      consider the <a href="#media-flinging-to-multiple-screens">Media Flinging
      to Multiple Screens</a> use case unaddressed by the <a href="#previous-version">previous version of the Presentation API</a>. This
      section describes the interfaces to the extend discussed in the Second
      Screen Presentation Community Group. Readers are encouraged to consult
      the <a href="#example">Example</a> and <a href="#algorithms">Algorithms</a> sections together with this section for a
      more complete understanding of the technical parts of this specification.
    </p>
    <h3 id="navigatorpresentation"><span class="secno">6.1 </span>
      <code>NavigatorPresentation</code>
    </h3>
    <pre class="idl">interface NavigatorPresentation : EventTarget {
  readonly attribute PresentationSession? session;
  Promise&lt;PresentationSession&gt; startSession(DOMString url, DOMString? presentationId);
  Promise&lt;PresentationSession&gt; joinSession(DOMString url, DOMString? presentationId);
  attribute EventHandler onavailablechange;
};

partial interface Navigator {
  readonly attribute NavigatorPresentation presentation;
};
</pre>
    <h3 id="availablechangeevent"><span class="secno">6.2 </span>
      <code>AvailableChangeEvent</code>
    </h3>
    <p>
      Fired at the primary screen's <code>NavigatorPresentation</code> object,
      when screen availability changes.
    </p>
    <pre class="idl">[Constructor(DOMString type, optional AvailableChangeEventInit eventInitDict)]
interface AvailableChangeEvent : Event {
  readonly attribute boolean available;
};

dictionary AvailableChangeEventInit : EventInit {
  boolean available;
};
</pre>
    <h3 id="presentationsession"><span class="secno">6.3 </span>
      <code>PresentationSession</code>
    </h3>
    <p>
      An object representing the established presentation session.
    </p>
    <pre class="idl">enum PresentationSessionState { "connected", "disconnected" /*, "resumed" */ };

interface PresentationSession : EventTarget {
  readonly DOMString? id;
  readonly attribute PresentationSessionState state;
  void postMessage(DOMString message);
  void close();
  attribute EventHandler onmessage;
  attribute EventHandler onstatechange;
};
</pre>
    <h2 id="algorithms"><span class="secno">7 </span>
      Algorithms
    </h2>
    <p>
      These algorithms define the behavior of the
      <code>NavigatorPresentation</code> and <code>PresentationSession</code>
      interfaces declared in the <a href="#interfaces">Interfaces</a> section.
    </p>
    <p>
      Let <em>D</em> be the set of presentations that are currently known to
      the user agent (regardles of their state). <em>D</em> is represented as a
      set of tuples <em>(U, I, S)</em> where <em>U</em> is the URL that is
      being presented; <em>I</em> is an alphanumeric identifier for the
      presentation; and <em>S</em> is the user agent's
      <code>PresentationSession</code> for the presentation. <em>U</em> and
      <em>I</em> together uniquely identify the
      <code>PresentationSession</code> of the corresponding presentation.
    </p>
    <p class="open-issue">
      Need to add xrefs to term definitions: promise, task, assert, URL, etc.
    </p>
    <h3 id="screen-availability-listener-added"><span class="secno">7.1 </span>
      Screen Availability Listener Added
    </h3>
    <p>
      When a new event handler <em>E</em> is added to
      <code>NavigatorPresentation.onavailablechange</code>, the user agent must
      run the following steps:
    </p>
    <ol>
      <li>If the user agent is not already searching for screens compatible
      with the Presentation API, then:
        <ol>
          <li>Queue a task to search for screens that are compatible with the
          Presentation API.
          </li>
        </ol>
      </li>
      <li>If the search for screens discovers at least one compatible screen,
      then:
        <ol>
          <li>Queue a task to fire an event named <code>availablechange</code>
          at <em>E</em> (and only <em>E</em>) with the event's
          <code>available</code> property set to <code>true</code>.
          </li>
        </ol>
      </li>
    </ol>
    <p class="note">
      The mechanism used to search for compatible screens is up to the user
      agent. The user agent may choose search for screens at any time, not just
      when event handlers are added to
      <code>NavigatorPresentation.onavailablechange</code>.
    </p>
    <p class="open-issue">
      Do we want to fire the event at all handlers, or only the newly added
      one?
    </p>
    <h3 id="screen-availability-listener-removed"><span class="secno">7.2 </span>
      Screen Availability Listener Removed
    </h3>
    <p>
      When the last event handler is removed from
      <code>NavigatorPresentation.onavailablechange</code>, the user agent may
      run the following steps:
    </p>
    <ol>
      <li>Cancel any pending tasks to search for screens that are compatible
      with the Presentation API.
      </li>
    </ol>
    <h3 id="no-screens-available"><span class="secno">7.3 </span>
      No Screens Available
    </h3>
    <p>
      When the set of available screens becomes empty (e.g., because the user
      agent has lost its network connection), the user agent must run the
      following steps:
    </p>
    <ol>
      <li>If there are no event handlers added to
      <code>NavigatorPresentation.onavailablechange</code>, then:
        <ol>
          <li>Abort these steps.
          </li>
        </ol>
      </li>
      <li>Queue a task to fire an event named <code>availablechange</code> at
      all the event handlers added to
      <code>NavigatorPresentation.onavailablechange</code> with the event's
      <code>available</code> property set to <code>false</code>.
      </li>
    </ol>
    <h3 id="start-session"><span class="secno">7.4 </span>
      Start Session
    </h3>
    <p>
      When <code>NaviagatorPresentaton.startSession(presentationUrl,
      presentationId)</code> is called, the user agent must run the following
      steps.
    </p>
    <dl>
      <dt>
        Input
      </dt>
      <dd>
        <code>presentationUrl</code>, the URL of the document to be presented
      </dd>
      <dd>
        <code>presentationId</code>, an optional identifier for the
        presentation
      </dd>
      <dt>
        Output
      </dt>
      <dd>
        <em>P</em>, a Promise
      </dd>
    </dl>
    <ol>
      <li>Let <em>P</em> be a new Promise.
      </li>
      <li>Return <em>P</em>.
      </li>
      <li>If no screens are available that are compatible with the Presentation
      API, run these steps:
        <ol>
          <li>Reject <em>P</em> with a "NoScreensAvailable" exception.
          </li>
          <li>Abort all remaining steps.
          </li>
        </ol>
      </li>
      <li>Queue a task <em>T</em> to request user permission for the use of a
      presentation screen.
      </li>
      <li>If <em>T</em> completes with the user <em>granting permission</em> to
      use a screen, run the following steps:
        <ol>
          <li>If <code>presentationId</code> is not <em>undefined</em>, assign
          <em>I</em> to that that <code>presentationId</code>.
          </li>
          <li>If <code>presentationId</code> is <code>undefined</code>, let
          <em>I</em> be a random alphanumeric value of at least 16 characters
          drawn from the characters <code>[A-Za-z0-9]</code>.
          </li>
          <li>Create a new <code>PresentationSession</code> <em>S</em>.
          </li>
          <li>Set <code>S.url</code> to <code>presentationUrl</code>, set
          <code>S.id</code> to <em>I</em>, and set <code>S.state</code> to
          <code>disconnected</code>.
          </li>
          <li>Add <em>(S.url, S.id, S)</em> to <em>D</em>.
          </li>
          <li>Resolve <em>P</em> with <em>S</em>.
          </li>
          <li>Initiate the <em>Presentation Connection</em> algorithm for <em>
            S</em>.
          </li>
        </ol>
      </li>
      <li>If <em>T</em> completes with the user <em>denying permission</em>,
      run the following steps:
        <ol>
          <li>Reject <em>P</em> with a "PermissionDenied" exception.
          </li>
        </ol>
      </li>
    </ol>
    <p class="note">
      The implementation of the permission request is up to the user agent; for
      example it may show the user a dialog and allow the user to select an
      available screen (granting permission), or cancel the selection (denying
      permission).
    </p>
    <p class="open-issue">
      Do we want to distinguish the permission-denied outcome from the
      no-screens-available outcome? Developers would be able to infer it anyway
      from <code>onavailablechange</code>.
    </p>
    <h3 id="join-session"><span class="secno">7.5 </span>
      Join Session
    </h3>
    <p>
      When <code>NavigatorPresentation.joinSession(presentationUrl,
      presentationId)</code> is called, the user agent must run the following
      steps.
    </p>
    <dl>
      <dt>
        Input
      </dt>
      <dd>
        <code>presentationUrl</code>, the URL of the document being presented
      </dd>
      <dd>
        <code>presentationId</code>, the identifier for the presentation
      </dd>
      <dt>
        Output
      </dt>
      <dd>
        <em>P</em>, a Promise
      </dd>
    </dl>
    <ol>
      <li>Let <em>P</em> be a new Promise.
      </li>
      <li>Return <em>P</em>.
      </li>
      <li>Let <em>D</em> be the set of presentations known by the user agent.
      </li>
      <li>Queue a task <em>T</em> to run the following steps in order:
        <ol>
          <li>For each presentation <em>(U, I, S)</em> in <em>D</em>,
            <ol>
              <li>Let <em>u</em> equal <em>U</em>, <em>i</em> equal <em>I</em>,
              and <em>s</em> equal <em>S</em>.
              </li>
              <li>If <em>u</em> is equal to <code>presentationUrl</code> and
              <em>i</em> is equal to <code>presentationId</code>, run the
              following steps:
                <ol>
                  <li>Resolve <em>P</em> with <em>S</em>.
                  </li>
                  <li>Initiate the <em>Presentation Connection</em> algorithm
                  for <em>S</em>.
                  </li>
                  <li>Abort the remaining steps of <em>T</em>.
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>Reject <em>P</em> with a "NoPresentationFound" exception.
          </li>
        </ol>
      </li>
    </ol>
    <p class="open-issue">
      If no matching presentation is found, we could leave the Promise pending
      in case a matching presentation is started in the future.
    </p>
    <h3 id="session-close"><span class="secno">7.6 </span>
      Session Close
    </h3>
    <p>
      When <code>PresentationSession.close()</code> is called on a
      <code>PresentationSession</code> <em>S</em>, the user agent must run the
      following steps:
    </p>
    <ol>
      <li>If <em>S.state</em> is not <code>connected</code>, then:
        <ol>
          <li>Abort these steps.
          </li>
        </ol>
      </li>
      <li>Set <em>S.state</em> to <code>disconnected.</code>
      </li>
      <li>Let <em>D</em> be the set of presentations known by the user agent.
      </li>
      <li>Queue a task <em>T</em> to run the following steps in order:
        <ol>
          <li>For each presentation <em>(U, I, S')</em> in <em>D</em>,
            <ol>
              <li>Let <em>u</em> equal <em>U</em>, <em>i</em> equal <em>I</em>,
              and <em>s</em> equal <em>S'</em>.
              </li>
              <li>If <em>u</em> is equal to <em>S.url</em> and <em>i</em> is
              equal to <em>S.id</em>, run the following steps:
                <ol>
                  <li>Queue a task to fire an event named
                  <code>statechange</code> at <em>s.onstatechange</em>.
                  </li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
    <h3 id="presentation-connection"><span class="secno">7.7 </span>
      Presentation Connection
    </h3>
    <p>
      When the user agent has created a <code>PresentationSession</code>
      <em>S</em> to resolve a promise returned from
      <code>NavigatorPresentation.startSession</code>, or resolved a promise
      returned from to <code>NavigatorPresentation.joinSession</code> with
      <em>S</em>, it must run the following steps:
    </p>
    <ol>
      <li>If <em>S.state</em> is <code>connected</code>, then:
        <ol>
          <li>Abort all remaining steps.
          </li>
        </ol>
      </li>
      <li>Queue a task <em>T</em> to connect <em>S</em> to the document that is
      presenting <em>S.url</em>.
      </li>
      <li>If <em>T</em> completes successfully, run the following steps:
        <ol>
          <li>Set <em>S.state</em> to <code>connected.</code>
          </li>
          <li>Let <em>D</em> be the set of presentations known by the user
          agent.
          </li>
          <li>Queue a task <em>T</em> to run the following steps in order:
            <ol>
              <li>For each presentation <em>(U, I, S')</em> in <em>D</em>,
                <ol>
                  <li>Let <em>u</em> equal <em>U</em>, <em>i</em> equal
                  <em>I</em>, and <em>s</em> equal <em>S'</em>.
                  </li>
                  <li>If <em>u</em> is equal to <em>S.url</em> and <em>i</em>
                  is equal to <em>S.id</em>, run the following steps:
                    <ol>
                      <li>Queue a task to fire an event named
                      <code>statechange</code> at <em>s.onstatechange</em>.
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
    <p class="note">
      If <em>T</em> does not complete successfully, the user agent may choose
      to re-execute the Presentation Connection algorithm at a later time.
    </p>
    <p class="note">
      The mechanism that is used to connect the opening document with the
      presented document is an implementation choice of the user agent. The
      connection must provide a two-way messaging abstraction capable of
      carrying <code>DOMString</code> payloads in a reliable and in-order
      fashion as described in the <em>Send Message</em> and <em>Receive
      Message</em> steps below.
    </p>
    <p class="open-issue">
      Do we want to notify the caller of a failure to connect, i.e. with an
      "error" onstatechange?
    </p>
    <p class="open-issue">
      Do we want to pass the new state as a property of the statechange event?
    </p>
    <p class="open-issue">
      Need to further specify the semantics of the messaging channel (using
      WebSockets or MessagePort as a reference).
    </p>
    <h3 id="todo"><span class="secno">7.8 </span>
      TODO
    </h3>
    <p class="open-issue">
      Need algorithm for send message
    </p>
    <p class="open-issue">
      Need algorithm for receive message
    </p>
    <p class="open-issue">
      Need algorithm for initialization of the presented document
    </p>
    <p class="open-issue">
      We could write this spec in a way that distinguished the state of the
      presentation (owned by the user agent) from the state of the
      PresentationSession (owned by a specific document); however these should
      always be sync and it would likely result in more confusion than clarity.
    </p>
    <h2 class="no-num" id="references">
      References
    </h2>
    <div id="anolis-references"><dl><dt id="refsHTML5">[HTML5]
<dd><cite><a href="http://www.w3.org/html/wg/drafts/html/CR/">HTML5</a></cite>, Robin Berjon, Steve Faulkner, Travis Leithead et al.. W3C.

<dt id="refsRFC2119">[RFC2119]
<dd><cite><a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a></cite>, Scott Bradner. IETF.

<dt id="refsWEBIDL">[WEBIDL]
<dd><cite><a href="http://heycam.github.io/webidl/">Web IDL</a></cite>, Cameron McCormack. W3C.

</dl></div>
    <h2 class="no-num" id="acknowledgments">
      Acknowledgments
    </h2>
    <p>
      Thanks to Wayne Carr, Louay Bassbous, Anssi Kostiainen, 闵洪波 (Hongbo Min),
      Anton Vayvod, and Mark Foltz for help with editing, reviews and feedback
      to this draft.
    </p>
  

