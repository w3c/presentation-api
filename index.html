<!DOCTYPE html><html lang="en-US"><head>
    <meta charset="UTF-8">
    <title>
      Presentation API
    </title>
    <style>
@media print {
     [data-anolis-spec]::after { content:"[" attr(data-anolis-spec) "]"; font-size:.6em; vertical-align:super; text-transform:uppercase }
    }
    </style>
    <link href="http://www.w3.org/community/src/css/spec/cg-draft.css" rel="stylesheet" type="text/css">
    <style type="text/css">
/* Note formatting taken from HTML5 spec */
    .note { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #E9FBE9; border-color: #52E052; }
    .note em, .warning em, .note i, .warning i { font-style: normal; }
    p.note, div.note { padding: 0.5em 2em; }
    span.note { padding: 0 2em; }
    .note p:first-child { margin-top: 0; }
    .note p:last-child { margin-bottom: 0; }
    p.note:before { content: 'Note: '; font-weight: bolder;}

    .open-issue { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #fbfbe9; border-color: #faf9a5; }
    .open-issue em, .warning em, .open-issue i, .warning i { font-style: normal; }
    p.open-issue, div.open-issue { padding: 0.5em 2em; }
    span.open-issue { padding: 0 2em; }
    .open-issue p:first-child { margin-top: 0; }
    .open-issue p:last-child { margin-bottom: 0; }
    p.open-issue:before { content: 'Open issue: '; font-weight: bolder;}

    .non-normative { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #E9FBE9; border-color: #52E052; }
    p.non-normative:before { content: 'Non-normative: '; font-weight: bolder;}
    p.non-normative, div.non-normative { padding: 0.5em 2em; }


    /* Pre.idl formatting taken from HTML5 spec */
    pre.idl { border: solid thin #d3d3d3; background: #FCFCFC; color: black; padding: 0.5em 1em; position: relative; }
    pre.idl :link, pre.idl :visited { color: inherit; background: transparent; }
    pre.idl::before { content: "IDL"; font: bold small sans-serif;
    padding: 0.5em; background: white; position: absolute; top: 0;
    margin: -1px 0 0 -4em; width: 1.5em; border: thin solid;
    border-radius: 0 0 0 0.5em }

    /* .example idl formatting taken from HTML5 nightly spec */
    .example {
        display: block;
        color: #222222;
        background: #FCFCFC;
        border-left-style: solid;
        border-color: #c0c0c0;
        border-left-width: 0.25em;
        margin-left: 1em;
        padding-left: 1em;
        padding-bottom: 0.5em;
    }

    .algorithm li {
        margin-bottom: 0.5em;
    }

    .interface dd, .parameters dt {
        margin-bottom: 0.5em;
    }

    code { color: orangered; }
    </style>
  </head>
  <body>
    <div class="head">
      
<!--begin-logo-->
<p><a href="http://www.w3.org/"><img alt="W3C" src="https://www.w3.org/Icons/w3c_home" width="72" height="48"></a></p>
<!--end-logo-->
      <h1>
        Presentation API
      </h1>
      <h2 class="no-num no-toc" id="draft-report-22-september-2014">
        Draft Report - 22 September 2014
      </h2>
      <dl>
        <dt>
          This Version:
        </dt>
        <dd>
          <!--begin-link--><a href="http://webscreens.github.io/presentation-api/ 
          ">http://webscreens.github.io/presentation-api/ 
          </a><!--end-link-->
        </dd>
        <dt>
          Latest Published Version
        </dt>
        <dd>
          <!--begin-link--><a href="http://webscreens.github.io/presentation-api/ 
          ">http://webscreens.github.io/presentation-api/ 
          </a><!--end-link-->
        </dd>
        <dt>
          <a id="previous-version">Previous Version:</a>
        </dt>
        <dd>
          <a href="http://webscreens.github.io/presentation-api/20131112/">http://webscreens.github.io/presentation-api/20131112/</a>
        </dd>
        <dt>
          Participate:
        </dt>
        <dd>
          Send feedback to the community group's mailing list <a href="http://lists.w3.org/Archives/Public/public-webscreens/">public-webscreens@w3.org</a>,
          or <a href="https://github.com/webscreens/presentation-api/issues">create or
          browse open issues</a> on GitHub. Also, you may join on the <a href="irc://irc.w3.org:6665/#webscreens">CG's IRC channel</a>.
        </dd>
        <dt>
          Version History:
        </dt>
        <dd>
          <!--begin-link--><a href="https://github.com/webscreens/presentation-api/commits/">https://github.com/webscreens/presentation-api/commits/</a><!--end-link-->
        </dd>
        <dt>
          Editors:
        </dt>
        <dd>
          <a href="mailto:dominik.rottsches@intel.com">Dominik Röttsches</a>,
          Intel
        </dd>
      </dl>
      <p class="copyright">
        <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>
        © 2014 the Contributors to the Presentation API Specification,
        published by the <a href="http://www.w3.org/community/webscreens/">Second Screen Presentation
        Community Group</a> under the <a href="https://www.w3.org/community/about/agreements/final/">W3C Community
        Final Specification Agreement (FSA)</a>. A human-readable <a href="http://www.w3.org/community/about/agreements/fsa-deed/">summary</a> is
        available.
      </p>
      <hr>
    </div>
    <h2 class="no-num no-toc" id="abstract">
      Abstract
    </h2>
    <p>
      This specification defines an API to enable web content to access
      external presentation-type displays and use them for presenting web
      content.
    </p>
    <h2 class="no-num no-toc" id="sotd">
      Status of this Document
    </h2>
    <p>
      This specification was published by the <a href="http://www.w3.org/community/webscreens/">Second Screen Presentation
      Community Group</a>. It is not a W3C Standard nor is it on the W3C
      Standards Track. Please note that under the <a href="http://www.w3.org/community/about/agreements/final/">W3C Community Final
      Specification Agreement (FSA)</a> other conditions apply. Learn more
      about <a href="http://www.w3.org/community/">W3C Community and Business
      Groups</a>.
    </p>
    <p>
      This report documents the use cases, requirements, examples and
      interfaces needed to enable web pages to display web content on secondary
      screens. It is an evolved version of the <a href="http://webscreens.github.io/presentation-api/20131112/">initial
      Presentation API</a> that represents the result of discussions within the
      Second Screen Presentation Community Group so far. API semantics still
      need to be specified. The report may serve as starting point for a
      possible Working Group chartered to work on the same topic.
    </p>
    <h2 class="no-num no-toc" id="table-of-contents">
      Table of Contents
    </h2>
<!--begin-toc-->
<ol class="toc">
 <li><a href="#introduction"><span class="secno">1 </span>
      Introduction
    </a>
  <ol>
   <li><a href="#use-cases"><span class="secno">1.1 </span>
      Use Cases
    </a>
    <ol>
     <li><a href="#presentations"><span class="secno">1.1.1 </span>
      Presentations
    </a></li>
     <li><a href="#video-and-image-sharing"><span class="secno">1.1.2 </span>
      Video and Image Sharing
    </a></li>
     <li><a href="#gaming"><span class="secno">1.1.3 </span>
      Gaming
    </a></li>
     <li><a href="#media-flinging-to-multiple-screens"><span class="secno">1.1.4 </span>
      Media Flinging to Multiple Screens
    </a></ol></ol></li>
 <li><a href="#requirements"><span class="secno">2 </span>
      Requirements
    </a>
  <ol>
   <li><a href="#functional-requirements"><span class="secno">2.1 </span>
      Functional Requirements
    </a></li>
   <li><a href="#non-functional-requirements"><span class="secno">2.2 </span>
      <span>Non-Functional Requirements</span>
    </a></ol></li>
 <li><a href="#conformance"><span class="secno">3 </span>
      Conformance
    </a></li>
 <li><a href="#terminology"><span class="secno">4 </span>
      Terminology
    </a></li>
 <li><a href="#example"><span class="secno">5 </span>
      Example
    </a>
  <ol>
   <li><a href="#starting-new-presentations"><span class="secno">5.1 </span>
      Starting New Presentations
    </a></li>
   <li><a href="#reconnecting-to-existing-presentations"><span class="secno">5.2 </span>
      Reconnecting to Existing Presentations
    </a></li>
   <li><a href="#open-questions"><span class="secno">5.3 </span>
      Open Questions
    </a></li>
   <li><a href="#usage-on-remote-screen"><span class="secno">5.4 </span>
      Usage on Remote Screen
    </a></ol></li>
 <li><a href="#interfaces"><span class="secno">6 </span>
      Interfaces
    </a>
  <ol>
   <li><a href="#navigatorpresentation"><span class="secno">6.1 </span>
      <code>NavigatorPresentation</code>
    </a></li>
   <li><a href="#availablechangeevent"><span class="secno">6.2 </span>
      <code>AvailableChangeEvent</code>
    </a></li>
   <li><a href="#presentationsession"><span class="secno">6.3 </span>
      <code>PresentationSession</code>
    </a></ol></li>
 <li><a href="#algorithms"><span class="secno">7 </span>
      Algorithms
    </a>
  <ol>
   <li><a href="#the-screen-availability-algorithm"><span class="secno">7.1 </span>
      The Screen Availability algorithm
    </a></li>
   <li><a href="#the-start-session-algorithm"><span class="secno">7.2 </span>
      The Start Session algorithm
    </a></li>
   <li><a href="#the-join-session-algorithm"><span class="secno">7.3 </span>
      The Join Session algorithm
    </a></li>
   <li><a href="#the-close-session-algorithm"><span class="secno">7.4 </span>
      The Close Session algorithm
    </a></li>
   <li><a href="#the-presentation-initialization-algorithm"><span class="secno">7.5 </span>
      The Presentation Initialization algorithm
    </a></ol></li>
 <li><a class="no-num" href="#references">
      References
    </a></li>
 <li><a class="no-num" href="#acknowledgments">
      Acknowledgments
    </a></ol>
<!--end-toc-->
    <h2 id="introduction"><span class="secno">1 </span>
      Introduction
    </h2><em>This section is non-normative.</em>
    <p>
      This specification aims to make secondary displays such as a projector or
      a connected TV available to the web and takes into account displays that
      are attached using wired (HDMI, DVI or similar) and wireless technologies
      (MiraCast, Chromecast, DLNA, AirPlay or similar).
    </p>
    <p>
      Devices with limited screen size lack the ability to show content to a
      larger audience, for example a group of colleagues in a conference room,
      or friends and family at home. Showing content on an external large
      display helps to improve the perceived quality and impact of the
      presented content.
    </p>
    <p>
      At its core, this specification enables an exchange of messages between a
      requesting page and a presentation page shown in the secondary display.
      How those messages are transmitted is left to the UA in order to allow
      for use of display devices that can be attached in a wide variety of
      ways. For example, when a display device is attached using HDMI or
      MiraCast, the UA on the requesting device can render the requested
      presentation page in that same UA, but instead of displaying in a window
      on that same device, it can use whatever means the operating system
      provides for using those external displays. In that case, both the
      requesting page and the presentation page run on the requesting device
      and the operating system is used to route the presentation display output
      to the other display device. The second display device doesn't need to
      know anything about this spec or that the content involves HTML5.
    </p>
    <p>
      Alternately, some types of external displays may be able to render HTML5
      themselves and may have defined their own way to send messages to that
      content. In that case, the UA on the requesting device would not need to
      render the presentation page itself. Instead, the UA could act as a proxy
      translating the request to show a page and the messages into the form
      understood by the display device.
    </p>
    <p>
      This way of attaching to displays could be enhanced in the future through
      definition of a standard protocol for delivering these types of messages
      that display devices could choose to implement.
    </p>
    <p>
      The API defined here is intended be used with UAs that attach to display
      devices through any of the above means.
    </p>
    <h3 id="use-cases"><span class="secno">1.1 </span>
      Use Cases
    </h3>
    <h4 id="presentations"><span class="secno">1.1.1 </span>
      Presentations
    </h4>
    <p>
      A user is preparing a set of slides for a talk. Using a web based
      service, she is editing her slides and speaker notes on the primary
      screen, while the secondary larger screen shows a preview of the current
      slide. When the slides are done, her mobile phone allows her to access
      them from an online service while on the go. Coming to the conference,
      using wireless display technology, she would like to present her slides
      on the stage screen from her mobile phone. The phone's touch screen helps
      her to navigate slides and presents a slide preview, while the projector
      shows her slides to the audience.
    </p>
    <p>
      <b>Requirements:</b> R1, R3, R4, R5, R7
    </p>
    <h4 id="video-and-image-sharing"><span class="secno">1.1.2 </span>
      <a id="video-sharing">Video and Image Sharing</a>
    </h4>
    <p>
      Using an online video or image sharing service, a user would like to show
      memorable moments to her friends. Using a device with a small screen, it
      is impossible to show the content to a large group of people. Connecting
      an external TV screen or projector to her device - with a cable or
      wirelessly - the online sharing service now makes use of the connected
      display, allowing a wider audience to enjoy the content.
    </p>
    <p>
      The web page shows UI elements that allow the user to trigger displaying
      content on the secondary display (e.g a "send to second screen" ) only if
      there is at least one secondary screen available.
    </p>
    <p>
      <b>Requirements:</b> R1, R3, R4, R5, R7
    </p>
    <h4 id="gaming"><span class="secno">1.1.3 </span>
      Gaming
    </h4>
    <p>
      Splitting the gaming experience into a near screen controller and a large
      screen visual experience, new gaming experiences can be created.
      Accessing the local display on the small screen device and an external
      larger display allows for richer web-based gaming experiences.
    </p>
    <p>
      <b>Requirements:</b> R1, R3, R4, R5, R7
    </p>
    <h4 id="media-flinging-to-multiple-screens"><span class="secno">1.1.4 </span>
      Media Flinging to Multiple Screens
    </h4>Alice enters a video sharing site using a browser on her tablet. Next,
    Alice picks her favorite video from the site, and the video starts to play
    on her tablet. While the video is playing Alice clicks a button "Share on
    different screen". The browser provides a user interface that lists all the
    screens Alice has around her home, asking her to select one. The screens
    are identified by names that are familiar to Alice. Alice picks one screen
    from the list, "Alice's big TV", and the video playback continues
    seamlessly on the selected screen. Next she decides to switch the playback
    to a different screen. She clicks the same button "Share on different
    screen" provided by the site, and the browser presents the user interface
    that lists all the screens. Alice picks another screen from the list,
    "Alice's kitchen TV", and the playback resumes on that screen. Video site
    also provides a feature to see the action (Alice is watching a soccer game)
    from different angle. Alice clicks a button "Select screen for additional
    angle", and the browser asks Alice similarly to select the screen to be
    used for playback. Alice picks "Alice's Projector" and the soccer game is
    shown on the projector from a different angle, in parallel to the content
    being played back on "Alice's kitchen TV".
    <p>
      <b>Requirements:</b> R1, R3, R4, R5, R6, R7
    </p>
    <h2 id="requirements"><span class="secno">2 </span>
      Requirements
    </h2>
    <h3 id="functional-requirements"><span class="secno">2.1 </span>
      Functional Requirements
    </h3>
    <ul>
      <li>
        <b>Discovery / Availability</b>
        <ul>
          <li>R1: The UA must provide a way to find out whether at least one
          secondary screen is available.
          </li>
        </ul>
      </li>
    </ul>
    <p class="note">
      Multi-Screen enumeration and named identification removed, after
      discussion on the mailing list, cmp. <a class="external free" href="http://lists.w3.org/Archives/Public/public-webscreens/2014Feb/0021.html" rel="nofollow">
      http://lists.w3.org/Archives/Public/public-webscreens/2014Feb/0021.html</a> :
    </p>
    <ul>
      <li>
        <b>Launching Presentation</b>
        <ul>
          <li>R3: The UA must provide a means of start sending content to the
          secondary screen.
          </li>
        </ul>
      </li>
      <li>
        <b>Resuming Presentation</b>
        <ul>
          <li>R4: The UA must be able to resume an existing session with
          content being displayed on the secondary screen.
          </li>
        </ul>
      </li>
      <li>
        <b>Communication</b>
        <ul>
          <li>R5: The UA must enable exchanging data between the primary and
          the secondary screen in order to have a control channel between the
          primary and secondary page.
          </li>
          <li>R6: The UA must not make assumptions about the the execution
          locality of the user agent of the remote page it communicates with
          (i.e. the secondary page might run on a remote user agent and thus
          the link between the two pages' UA must be loosely coupled).
          </li>
        </ul>
      </li>
    </ul>
    <ul>
      <li>
        <b>Signaling Disconnection</b>
        <ul>
          <li>R7: The UA must signal disconnection from the presentation page
          to the primary page and vice versa.
          </li>
        </ul>
      </li>
    </ul>
    <h3 id="non-functional-requirements"><span class="secno">2.2 </span>
      <span id="Non-Functional_Requirements">Non-Functional Requirements</span>
    </h3>
    <ul>
      <li>
        <b>Power Saving Friendly</b>
        <ul>
          <li>All API design decisions must be analyzed from a power efficiency
          point of view. Especially when using wireless display technologies or
          querying availability over a radio channel, care needs to be taken to
          design the API in a way that does not pose obstacles to using radio
          resources in an efficient way. For example, powering up the wireless
          display detection only when needed.
          </li>
        </ul>
      </li>
    </ul>
    <h2 id="conformance"><span class="secno">3 </span>
      Conformance
    </h2>
    <p>
      All diagrams, examples, and notes in this specification are
      non-normative, as are all sections explicitly marked non-normative.
      Everything else in this specification is normative.
    </p>
    <p>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in RFC
      2119. For readability, these words do not appear in all uppercase letters
      in this specification. <a href="#refsRFC2119">[RFC2119]</a>
    </p>
    <p>
      Requirements phrased in the imperative as part of algorithms (such as
      "strip any leading space characters" or "return false and terminate these
      steps") are to be interpreted with the meaning of the key word ("must",
      "should", "may", etc.) used in introducing the algorithm.
    </p>
    <p>
      Conformance requirements phrased as algorithms or specific steps may be
      implemented in any manner, so long as the end result is equivalent. (In
      particular, the algorithms defined in this specification are intended to
      be easy to follow, and not intended to be performant.)
    </p>
    <h2 id="terminology"><span class="secno">4 </span>
      Terminology
    </h2>
    <p>
      The term <dfn id="presentation-display" title="presentation display">presentation display</dfn>
      refers to an external screen connected to the device that the user agent
      runs on.
    </p><!--    <p>
      The terms <span title="opener-browsing-context" data-anolis-spec=
      "w3c-html">opener browsing context</span> and <span title=
      "auxiliary browsing context" data-anolis-spec="w3c-html">auxiliary
      browsing context</span> are defined in <span data-anolis-ref=
      "">HTML5</span>.
    </p>
-->
    <p>
      The terms <a class="external" href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#event-handlers" data-anolis-spec="w3c-html">event handlers</a> and
      <a class="external" href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#event-handler-event-type" data-anolis-spec="w3c-html" title="event handler event type">event
      handler event types</a> are defined in <a href="#refsHTML5">[HTML5]</a>.
    </p>
    <p>
      This document provides interface definitions using the
      <a href="#refsWEBIDL">[WEBIDL]</a> standard.
    </p>
    <h2 id="example"><span class="secno">5 </span>
      Example
    </h2>
    <p>
      Running in a compliant user agent, code for presenting a page
      <code>http://example.org/presentation.html</code> on the presentation
      display looks as follows:
    </p>
    <pre class="example">/* controller.html */

&lt;button disabled id=show&gt;Show&lt;/button&gt;
&lt;button disabled id=stop&gt;Stop&lt;/button&gt;

&lt;script&gt;

var presentation = navigator.presentation,
    showButton = document.getElementById('show'),
    stopButton = document.getElementById('stop');

var session = null,
    screenAvailable = false,
    presentationUrl = 'http://example.org/presentation.html',
    previousSessionId = localStorage['sessionId'];

presentation.onavailablechange = function (e) {
    screenAvailable = e.available;
    updateButtons();
};

function tryJoin() {
    if (!previousSessionId) return;
    // Join an existing presentation if one exists.
    session = presentation.joinSession(presentationUrl, previousSessionId);
    console.log(session.state); // "unknown"
    session.onstatechange = handleSessionState;
}

function startPresent() {
    session = presentation.startSession(presentationUrl);
    console.log(session.state); // "unknown"
    session.onstatechange = handleSessionState;
}

function handleSessionState() {
    switch (session.state) {
        case 'connected':
            if (previousSessionId == session.id) {
                console.log("Joined existing session.");
            } else {
                console.log("New session opened.");
                localStorage['sessionId'] = session.id;
            }
            session.postMessage( /*...*/ );
            session.onmessage = function () { /*...*/
            };
            break;
        case 'disconnected':
            // Session join/start failed, or session terminated.
            break;
    }
    updateButtons();
}

function updateButtons() {
    var sessionConnected = session &amp;&amp; session.state == "connected";
    stopButton.disabled = !sessionConnected;
    stopButton.onClick = sessionConnected ? stopPresent : null;
    var sessionPendingOrConnected = sessionConnected || (session &amp;&amp; session.state == "unknown");
    showButton.disabled = !screenAvailable || sessionPendingOrConnected;
    showButton.onclick = screenAvailable &amp;&amp; !sessionPendingOrConnected ? startPresent : null;
}

function stopPresent() {
    session.close();
}

tryJoin();
&lt;/script&gt;
</pre>
    <p>
      The availability monitoring for secondary screens begins when the page
      adds an event listener for the <code>availablechange</code> event on the
      <code>navigator.presentation</code> object. If there are already
      available screens when the page adds the first event listener for the
      event, the UA synthesizes a single availablechange event to signal the
      availability.
    </p>
    <p class="open-issue">
      Do we want to fire an event immediately after the page registers for it?
      What's a best practice method for asynchronous notifications of this
      kind? See below in the <a href="#open-questions">Open Questions</a>
      section.
    </p>
    <p class="open-issue">
      It is an open issue whether to provide filter information as part of the
      request for notification of available screens. This could be useful when
      a particular application or capability is needed in order to display the
      contents of a presentation. One possible approach to this could be to
      provide the URL for the presentation and / or required options as part of
      the request for notification of available screens. If this was supported,
      only screens that satisfied the filter would trigger a notification.
    </p>
    <h4 id="starting-new-presentations"><span class="secno">5.1 </span>
      Starting New Presentations
    </h4>
    <p>
      The "Show" button's state (initially disabled) informs the user of the
      availability of secondary screen(s), and the button's state is updated if
      the availability changes. (The rationale of putting the actual boolean
      information into a property of the event <code>e.available</code> is to
      allow the implementation to optimize power consumption for network
      discovery of remote wireless screens. If this information was provided in
      a globally accessible flag, the network discovery could never be
      suspended for keeping the flag up to date.)
    </p>
    <p>
      Clicking the "Show" button calls
      <code>navigator.presentation.startSession()</code>, which causes the user
      agent to request from the user a screen to show the presentation. The
      <code>url</code> argument indicates the content to be presented.
    </p>
    <p>
      If the user selects a screen with an existing presentation showing the
      same <code>url</code> under the same <code>presentationId</code>, the
      opener page is connected to that existing presentation.
    </p>
    <p>
      If the user selects a screen without an existing presentation, or a
      screen presenting a different <code>url</code> or
      <code>presentationId</code>, the UA connects to the selected screen,
      brings up a new presentation window on it, and starts to show the content
      denoted by the <code>url</code> argument. The UA then connects the opener
      page to this new presentation and allows the opener page to exchange
      messages with it.
    </p>
    <p>
      <code>navigator.presentation.startSession(url, presentationId)</code>
      returns a <code>PresentationSession</code> object, initially in
      <code>"unknown"</code> state. Changes of the <code>state</code> property
      of the <code>PresentationSession</code> object are signalled through the
      <code>onstatechange</code> event handler.
    </p>
    <p>
      Once the UA established the connection to the presentation page, the
      state changes from <code>"unknown"</code> to <code>"connected"</code>. At
      this point, the opener page can communicate with the presentation page
      using the session's <code>postMessage()</code> to send messages and its
      <code>onmessage</code> event handler to receive messages.
    </p>
    <p>
      The presentation page will also have access to
      <code>PresentationSession</code> that it can use to send and receive
      messages with the opener page (see <a href="#usage-on-remote-screen">Usage on Remote Screen</a>).
    </p>
    <p>
      If the user cancels screen selection when the UA brings up the selection
      dialog, the <code>state</code> property of the
      <code>PresentationSession</code> object remains at
      <code>"unknown"</code>. If the UA attempts and for technical reasons
      fails at establishing a link with the presentation page, the
      <code>state</code> property transitions to <code>"disconnected"</code>.
    </p>
    <h4 id="reconnecting-to-existing-presentations"><span class="secno">5.2 </span>
      Reconnecting to Existing Presentations
    </h4>
    <p>
      The opener page may wish to reconnect to an existing presentation without
      prompting the user to select a screen. For example, the site could allow
      media items from different pages to be shown on the same presentation
      page, and does not want to prompt the user on each page to reconnect to
      that presentation.
    </p>
    <p>
      To reconnect, the page calls <code>joinSession(url,
      presentationId)</code>, which returns a <code>PresentationSession</code>,
      initially in <code>"unknown"</code> state.
    </p>
    <p>
      The <code>presentationId</code> argument in this case is the value of the
      <code>session.id</code> property of a previously established
      <code>PresentationSession</code>. This value is generated by the UA once
      a session is established through <code>startSession</code>.
    </p>
    <p>
      If the UA finds an existing presenting instance that matches the
      <code>url</code> and <code>presentationId</code> as was passed originally
      into <code>startSession</code>, the UA then transistions the state of the
      returned <code>PresentationSession</code> to <code>"connected"</code>.
      The requesting page can then communicate with the presentation as if the
      user had manually connected to it via <code>startSession</code>.
    </p>
    <p>
      If no such instance exists, the <code>state</code> of the returned
      <code>PresentationSession</code> transitions to
      <code>"disconnected"</code>.
    </p>
    <h4 id="open-questions"><span class="secno">5.3 </span>
      Open Questions
    </h4>
    <p class="open-issue">
      Do we need to insert into the description an additional permission prompt
      to grant the page access to the "one ore more screens are available"
      Information?
    </p>
    <p class="open-issue">
      Do we reload the presentation page after startSession() if the page was
      previously already shown on this screen?
    </p>
    <p class="open-issue">
      If there are already connected screens when the page subscribes to the
      <code>onavailablechange</code> event, we can handle this in two ways: We
      can synthesize one initial event to notify the page about available
      screens as soon as the first event handler is installed (as described).
      Or we can add another message like
      <code>navigator.presentation.getAvailable(function(available) { }
      );</code> to notify the page about available screens using this one-time
      asynchronous getter. Which way should we go?
    </p>
    <p class="open-issue">
      Do we need an additional state like resumed in order to identify resumed
      session? It seems that this could be handled on the page level. The
      opener page could ask the presentation page whether it is
      <code>"new"</code> or <code>"resumed"</code>.
    </p>
    <p class="open-issue">
      <del>If more than one presentation session exists with the same
      <code>url</code> and <code>presentationId</code> (on different screens)
      then what is the behavior of <code>joinSession(url,
      presentationId)</code>?</del> This can be resolved by having the UA
      generate different ids on different screens.
    </p>
    <p class="open-issue">
      If the page calls <code>startSession(url)</code> and
      <code>joinSession(url, presentationId)</code> with the same
      <code>url</code>, and the latter call has not resolved, behavior is not
      defined.
    </p>
    <h3 id="usage-on-remote-screen"><span class="secno">5.4 </span>
      Usage on Remote Screen
    </h3>
    <p>
      For addressing the requirement of communication between originating page
      and presentation page/screen, the presenting page can now use the same
      <code>session</code> object. It accesses this object through the
      <code>navigator.presentation.session</code> property, which is only
      non-<code>null</code> for the page on the presentation screen.
    </p>
    <pre class="example">if (navigator.presentation.session) {
  var session = navigator.presentation.session;
  // Communicate with opener page.
  session.postMessage(/*...*/);
  session.onmessage = function() {/*...*/};

  session.onstatechange = function() {
    switch (this.state) {
      case "disconnected":
        // Handle disconnection from opener page.
    }
  };
};
</pre>
    <p>
      When the content denoted by the <code>url</code> argument in the
      <code>requestSession()</code> example above is loaded, the page on the
      presentation screen will have its
      <code>navigator.presentation.session</code> property set to the session.
      This session is a similar object as in the first example. Here, its
      initial state is <code>"connected"</code>, which means we can use it to
      communicate with the opener page using <code>postMessage()</code> and
      <code>onmessage</code>.
    </p>
    <p>
      The presentation page can also monitor the connection state by listening
      for <code>statechange</code> events. When the state changes to
      <code>"disconnected"</code> the page is made aware of the fact that
      communication with the opener page was lost, but it can continue to
      display the current content. The communication can be re-established when
      a <code>statechange</code> event fires with a new state of
      <code>"connected"</code>.
    </p>
    <h2 id="interfaces"><span class="secno">6 </span>
      Interfaces
    </h2>
    <p>
      The interfaces described herein address the requirements outlined in the
      <a href="#use-cases">Use Cases</a> section, and specifically, also
      consider the <a href="#media-flinging-to-multiple-screens">Media Flinging
      to Multiple Screens</a> use case unaddressed by the <a href="#previous-version">previous version of the Presentation API</a>. This
      section describes the interfaces to the extend discussed in the Second
      Screen Presentation Community Group. Readers are encouraged to consult
      the <a href="#example">Example</a> and <a href="#algorithms">Algorithms</a> sections together with this section for a
      more complete understanding of the technical parts of this specification.
    </p>
    <p class="open-issue">
      Since we permit multiple opener pages to connect the same presentation
      page, we need to define how connection and disconnection of these pages
      is communicated to the presentation page (if at all).
    </p>
    <h3 id="navigatorpresentation"><span class="secno">6.1 </span>
      <code>NavigatorPresentation</code>
    </h3>
    <pre class="idl">interface NavigatorPresentation : EventTarget {
  readonly attribute PresentationSession? session;
  PresentationSession startSession(DOMString url, DOMString? presentationId);
  PresentationSession joinSession(DOMString url, DOMString? presentationId);
  attribute EventHandler onavailablechange;
};

partial interface Navigator {
  readonly attribute NavigatorPresentation presentation;
};
</pre>
    <h3 id="availablechangeevent"><span class="secno">6.2 </span>
      <code>AvailableChangeEvent</code>
    </h3>
    <p>
      Fired at the primary screen's <code>NavigatorPresentation</code> object,
      when screen availability changes.
    </p>
    <pre class="idl">[Constructor(DOMString type, optional AvailableChangeEventInit eventInitDict)]
interface AvailableChangeEvent : Event {
  readonly attribute boolean available;
};

dictionary AvailableChangeEventInit : EventInit {
  boolean available;
};
</pre>
    <h3 id="presentationsession"><span class="secno">6.3 </span>
      <code>PresentationSession</code>
    </h3>
    <p>
      An object representing the established presentation session.
    </p>
    <pre class="idl">enum PresentationSessionState { "unknown", "connected", "disconnected" };

interface PresentationSession : EventTarget {
  readonly DOMString? id;
  readonly attribute PresentationSessionState state;
  void postMessage(DOMString message);
  void close();
  attribute EventHandler onmessage;
  attribute EventHandler onstatechange;
};
</pre>
    <h2 id="algorithms"><span class="secno">7 </span>
      Algorithms
    </h2>
    <p>
      These algorithms are intended to define the behavior of the
      <code>NavigatorPresentation</code> and <code>PresentationSession</code>
      interfaces declared in the <a href="#interfaces">Interfaces</a> section.
    </p>
    <h3 id="the-screen-availability-algorithm"><span class="secno">7.1 </span>
      The Screen Availability algorithm
    </h3>
    <p>
      Run when an event handler is added to <code>onavailablechange</code>.
    </p>
    <h3 id="the-start-session-algorithm"><span class="secno">7.2 </span>
      The Start Session algorithm
    </h3>
    <p>
      Run when <code>startSession(url, presentationId)</code> is called.
    </p>
    <h3 id="the-join-session-algorithm"><span class="secno">7.3 </span>
      The Join Session algorithm
    </h3>
    <p>
      Run when <code>joinSession(url, presentationId)</code> is called.
    </p>
    <h3 id="the-close-session-algorithm"><span class="secno">7.4 </span>
      The Close Session algorithm
    </h3>
    <p>
      Run when <code>close()</code> is called on a
      <code>PresentationSession.</code>
    </p>
    <h3 id="the-presentation-initialization-algorithm"><span class="secno">7.5 </span>
      The Presentation Initialization algorithm
    </h3>
    <p>
      Run when a document opened by <code>startSession()</code> is loaded.
    </p>
    <h2 class="no-num" id="references">
      References
    </h2>
    <div id="anolis-references"><dl><dt id="refsHTML5">[HTML5]
<dd><cite><a href="http://www.w3.org/html/wg/drafts/html/CR/">HTML5</a></cite>, Robin Berjon, Steve Faulkner, Travis Leithead et al.. W3C.

<dt id="refsRFC2119">[RFC2119]
<dd><cite><a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a></cite>, Scott Bradner. IETF.

<dt id="refsWEBIDL">[WEBIDL]
<dd><cite><a href="http://dev.w3.org/2006/webapi/WebIDL/">Web IDL</a></cite>, Cameron McCormack. W3C.

</dl></div>
    <h2 class="no-num" id="acknowledgments">
      Acknowledgments
    </h2>
    <p>
      Thanks to Wayne Carr, Louay Bassbous, Anssi Kostiainen, 闵洪波 (Hongbo Min),
      Anton Vayvod, and Mark Foltz for help with editing, reviews and feedback
      to this draft.
    </p>
  

